diff --git a/ebpf-nfs/fw/xdp_fw_kern.h b/ebpf-nfs/fw/xdp_fw_kern.h
index aa06f43..c7bdbd1 100644
--- a/ebpf-nfs/fw/xdp_fw_kern.h
+++ b/ebpf-nfs/fw/xdp_fw_kern.h
@@ -87,7 +87,9 @@ int xdp_fw_prog(struct xdp_md *ctx)
 	
 	struct flow_ctx_table_leaf new_flow = {0};
 	struct flow_ctx_table_key flow_key  = {0};
-	struct flow_ctx_table_leaf *flow_leaf;
+	// struct flow_ctx_table_leaf *flow_leaf;
+	// struct flow_ctx_table_leaf *flow_leaf = malloc(sizeof(struct flow_ctx_table_leaf));
+  	// klee_make_symbolic(flow_leaf, sizeof(struct flow_ctx_table_leaf), "flow_leaf");
 
 	struct ethhdr *ethernet;
 	struct iphdr        *ip;
@@ -112,8 +114,9 @@ int xdp_fw_prog(struct xdp_md *ctx)
 	bpf_debug("ingress_ifindex: %d\n", ingress_ifindex);
 	
 	bpf_debug("I'm eth\n");
+
 	if(ethernet->h_proto != BE_ETH_P_IP)
-		goto EOP;
+			goto EOP;
 
 	bpf_debug("I'm ip\n");
 	
@@ -151,24 +154,41 @@ int xdp_fw_prog(struct xdp_md *ctx)
 
 	biflow(&flow_key);
 
-	// if (ip->saddr == 0x0a000001)
-	// 	return XDP_ABORTED;
-
 	if (ingress_ifindex == B_PORT){
-		flow_leaf = bpf_map_lookup_elem(&flow_ctx_table, &flow_key);
-			
+		struct flow_ctx_table_leaf *flow_leaf = (struct flow_ctx_table_leaf *)malloc(sizeof(struct flow_ctx_table_leaf));
+  		klee_make_symbolic(flow_leaf, sizeof(struct flow_ctx_table_leaf), "flow_leaf_L165");
+		// flow_leaf = bpf_map_lookup_elem(&flow_ctx_table, &flow_key);
+
+		int map_has_this_key = klee_int("flow_leaf_L165_map_has_key");
+		if (!map_has_this_key) {
+			flow_leaf = NULL;
+		}
+		
 		if (flow_leaf)
 			return bpf_redirect_map(&tx_port,flow_leaf->out_port, 0);
 		else 
 			return XDP_DROP;
 	} else {
-		flow_leaf = bpf_map_lookup_elem(&flow_ctx_table, &flow_key);
+		struct flow_ctx_table_leaf *flow_leaf = (struct flow_ctx_table_leaf *)malloc(sizeof(struct flow_ctx_table_leaf));
+  		klee_make_symbolic(flow_leaf, sizeof(struct flow_ctx_table_leaf), "flow_leaf_L174");
+		// flow_leaf = bpf_map_lookup_elem(&flow_ctx_table, &flow_key);
+
+		int map_has_this_key = klee_int("flow_leaf_L174_map_has_key");
+		if (!map_has_this_key) {
+			flow_leaf = NULL;
+		}
 			
 		if (!flow_leaf){
 			new_flow.in_port = B_PORT;
 			new_flow.out_port = A_PORT; //ctx->ingress_ifindex ;
 			bpf_map_update_elem(&flow_ctx_table, &flow_key, &new_flow, BPF_ANY);
 		}
+
+		if (flow_leaf) {
+			if (flow_leaf->out_port == 15 && flow_leaf->in_port == 85) {
+				return XDP_DROP;
+			}
+		}
 		
 		bpf_debug("redirecting to port %d\n", A_PORT);
 		return bpf_redirect_map(&tx_port, B_PORT, 0);
